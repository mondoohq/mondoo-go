// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: BUSL-1.1
// This implementation is inspired from https://github.com/shurcooL/githubv4/blob/master/gen.go

package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"

	"github.com/shurcooL/graphql/ident"
)

func main() {
	flag.Parse()

	err := generateSchema(".")
	if err != nil {
		log.Fatalln(err)
	}
}

// generateSchema generates the mondoogql package in basePath.
func generateSchema(basePath string) error {
	// fetch the graphql schema
	schema, err := loadSchema()
	if err != nil {
		return err
	}

	// write the generated files
	for filename, t := range templates {
		var buf bytes.Buffer
		// render go file
		err := t.Execute(&buf, schema)
		if err != nil {
			return err
		}

		// format go file with gofmt
		out, err := format.Source(buf.Bytes())
		if err != nil {
			log.Println(err)
			out = []byte("// gofmt error: " + err.Error() + "\n\n" + buf.String())
		}

		// write generated go file
		outfile := filepath.Join(basePath, filename)
		fmt.Println("writing", outfile)
		err = os.WriteFile(outfile, out, 0o644)
		if err != nil {
			return err
		}
	}

	return nil
}

// loadSchema loads the GraphQL schema from the Mondoo API.
func loadSchema() (schema interface{}, err error) {
	introspection := `
{
  __schema {
    queryType {
      name
    }
    mutationType {
      name
    }
    subscriptionType {
      name
    }
    types {
      ...FullType
    }
    directives {
      name
      description
      locations
      args {
        ...InputValue
      }
    }
  }
}

fragment FullType on __Type {
  kind
  name
  description
  fields(includeDeprecated: true) {
    name
    description
    args {
      ...InputValue
    }
    type {
      ...TypeRef
    }
    isDeprecated
    deprecationReason
  }
  inputFields {
    ...InputValue
  }
  interfaces {
    ...TypeRef
  }
  enumValues(includeDeprecated: true) {
    name
    description
    isDeprecated
    deprecationReason
  }
  possibleTypes {
    ...TypeRef
  }
}

fragment InputValue on __InputValue {
  name
  description
  type {
    ...TypeRef
  }
  defaultValue
}

fragment TypeRef on __Type {
  kind
  name
  ofType {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
              }
            }
          }
        }
      }
    }
  }
}
`
	apiEndpoint, apiHost := getAPIEndpoint()
	fmt.Printf("using endpoint %s\n", apiEndpoint)
	// do introspection query
	req, err := http.NewRequest(
		"POST",
		apiEndpoint,
		strings.NewReader(`{"query":`+strconv.Quote(introspection)+`}`),
	)
	if err != nil {
		return nil, err
	}

	// set headers
	token, ok := os.LookupEnv("MONDOO_API_TOKEN")
	if ok {
		req.Header.Set("Authorization", "bearer "+token)
	} else {
		log.Println("MONDOO_API_TOKEN environment variable not set")
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")
	req.Header.Set("Host", apiHost)
	req.Header.Set("Origin", "https://"+apiHost)

	// send request
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("non-200 OK status code: %v body: %q", resp.Status, body)
	}

	// decode graphql schema
	err = json.NewDecoder(resp.Body).Decode(&schema)
	return schema, err
}

// templates maps generated filenames with the go template to use for them.
var templates = map[string]*template.Template{
	// generate all enum types
	"enum.go": parseTemplate(`// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: MPL-2.0
// 
// Code generated by gen.go; DO NOT EDIT.

package mondoogql
{{range .data.__schema.types | sortByName}}{{if and (eq .kind "ENUM") (not (internal .name))}}
{{template "enum" .}}
{{end}}{{end}}

{{- define "enum" -}}
// {{.name}} {{.description | clean | endSentence}}
type {{.name}} string

{{if .description}}// {{.description | clean | fullSentence}}{{end}}
const ({{range .enumValues}}
	{{enumIdentifier $.name .name}} {{$.name}} = {{.name | quote}} {{if .description}}// {{.description | clean | fullSentence}}{{end}} {{end}}
)
{{- end -}}
`),

	// generate all input types
	"input.go": parseTemplate(`// Copyright (c) Mondoo, Inc.
// SPDX-License-Identifier: MPL-2.0
//
// Code generated by gen.go; DO NOT EDIT.

package mondoogql

// Input represents one of the Input structs:
//
// {{join (inputObjects .data.__schema.types) ", "}}.
type Input interface{}
{{range .data.__schema.types | sortByName}}{{if eq .kind "INPUT_OBJECT"}}
{{template "inputObject" .}}
{{end}}{{end}}


{{- define "inputObject" -}}
// {{.name}} {{.description | clean | endSentence}}
type {{.name}} struct {{"{"}}{{range .inputFields}}{{if eq .type.kind "NON_NULL"}}
	// {{ if .description }}{{ .description | clean | fullSentence }} {{ end }}(Required.)
	{{.name | identifier}} {{.type | type}} ` + "`" + `json:"{{.name}}" tfgen:"required=1"` + "`" + `{{end}}{{end}}
{{range .inputFields}}{{if ne .type.kind "NON_NULL"}}
	// {{ if .description }}{{ .description | clean | fullSentence }} {{ end }}(Optional.)
	{{.name | identifier}} {{.type | type}} ` + "`" + `json:"{{.name}},omitempty" tfgen:"required=0"` + "`" + `{{end}}{{end}}
}
{{- end -}}
`),
}

// parseTemplate takes a text template and returns a parsed template.
// This function is
func parseTemplate(text string) *template.Template {
	// typeString returns a string representation of GraphQL type t.
	var typeString func(t map[string]interface{}) string

	// typeString returns a string representation of GraphQL type t.
	typeString = func(t map[string]interface{}) string {
		switch t["kind"] {
		case "NON_NULL":
			s := typeString(t["ofType"].(map[string]interface{}))
			if !strings.HasPrefix(s, "*") {
				panic(fmt.Errorf("nullable type %q doesn't begin with '*'", s))
			}
			return s[1:] // Strip star from nullable type to make it non-null.
		case "LIST":
			return "*[]" + typeString(t["ofType"].(map[string]interface{}))
		default:
			return "*" + t["name"].(string)
		}
	}

	// compile template with custom functions
	return template.Must(template.New("").Funcs(template.FuncMap{
		"internal": func(s string) bool { return strings.HasPrefix(s, "__") },
		"quote":    strconv.Quote,
		"join":     strings.Join,
		"sortByName": func(types []interface{}) []interface{} {
			sort.Slice(types, func(i, j int) bool {
				ni := types[i].(map[string]interface{})["name"].(string)
				nj := types[j].(map[string]interface{})["name"].(string)
				return ni < nj
			})
			return types
		},
		"inputObjects": func(types []interface{}) []string {
			var names []string
			for _, t := range types {
				t := t.(map[string]interface{})
				if t["kind"].(string) != "INPUT_OBJECT" {
					continue
				}
				names = append(names, t["name"].(string))
			}
			sort.Strings(names)
			return names
		},
		"identifier": func(name string) string { return ToMixedCaps(ident.ParseLowerCamelCase(name)) },
		"enumIdentifier": func(enum, value string) string {
			return enum + ToMixedCaps(ident.ParseScreamingSnakeCase(value))
		},
		"type": typeString,
		"clean": func(v interface{}) string {
			if v == nil {
				return ""
			}
			s := v.(string)
			return strings.Join(strings.Fields(s), " ")
		},
		"endSentence": func(s string) string {
			if s == "" {
				return s
			}
			s = strings.ToLower(s[0:1]) + s[1:]
			switch {
			default:
				s = "represents " + s
			case strings.HasPrefix(s, "autogenerated "):
				s = "is an " + s
			case strings.HasPrefix(s, "specifies "):
				// Do nothing.
			}
			if !strings.HasSuffix(s, ".") {
				s += "."
			}
			return s
		},
		"fullSentence": func(s string) string {
			if !strings.HasSuffix(s, ".") {
				s += "."
			}
			return s
		},
	}).Parse(text))
}

// @afiune We need to re-implement this function since the underlying package changes the name
// based of initialism and brands, which we don't follow and therefore, break automations
//
// We can use it again once our backend generates same schemas
func ToMixedCaps(name ident.Name) string {
	for i, word := range name {
		if strings.EqualFold(word, "IDs") { // Special case, plural form of ID initialism.
			name[i] = "IDs"
			continue
		}

		// no initialism

		// no brands

		r, size := utf8.DecodeRuneInString(word)
		name[i] = string(unicode.ToUpper(r)) + strings.ToLower(word[size:])
	}
	return strings.Join(name, "")
}

func getAPIEndpoint() (string, string) {
	apiHost := "us.api.mondoo.com"
	apiEndpoint, err := url.JoinPath("https://", apiHost, "/query")
	if err != nil {
		log.Fatalf("invalid MONDOO_API_ENDPOINT: %v", err)
	}
	endpoint, ok := os.LookupEnv("MONDOO_API_ENDPOINT")
	if ok {
		if !strings.HasPrefix(endpoint, "http://") && !strings.HasPrefix(endpoint, "https://") {
			endpoint = "https://" + endpoint
		}
		apiEndpoint, err = url.JoinPath(endpoint, "/query")
		if err != nil {
			log.Fatalf("invalid MONDOO_API_ENDPOINT: %v", err)
		}
	}
	parsedUrl, err := url.Parse(apiEndpoint)
	if err != nil {
		log.Fatalf("invalid API url: %v", err)
	}

	return apiEndpoint, parsedUrl.Host
}
